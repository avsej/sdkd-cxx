#!/usr/bin/perl

my $Handles = {};
my $DataSets = {};
use Dir::Self;

BEGIN {
    push @INC, __DIR__ . '/../perl/';
    eval {
        require blib;
        blib->import('/home/mnunberg/src/Couchbase-Client/blib');
    }; if ($@) {
        print STDERR "Skipping native blib..: $@";
    }
}



################################################################################
################################################################################
################################################################################
### Message Containers and Conversion                                        ###
################################################################################
################################################################################
################################################################################


# This class defines the message 'header' (insofar as we can do this in JSON):
package CBSdkd::MessageRole;
use strict;
use warnings;
use Moo::Role;

# A message will always have a RequestID, Handle ID (0 if it's a special 'Control')
# message, and a command.
# A message will optionally (but usually, in practice) have a payload or data
# section.

has 'reqid' => (is => 'ro', required => 1);
has 'handle_id' => (is => 'ro', required => 1);
has 'command' => (is => 'ro', required => 1);

has 'payload' => (is => 'ro', default => sub { +{} });


# This function converts the perl object to a hash, suitable for passing to the
# JSON encoder
sub to_hash {
    my $self = shift;
    my $o = {
        Command => $self->command,
        ReqID => $self->reqid,
        Handle => $self->handle_id,
        $self->PayloadField, $self->payload
    };
    return $o;
}

# Subclass for requests.
package CBSdkd::Request;
use Moo;
use strict;
use warnings;
use JSON::XS qw(decode_json);
use Hash::Util qw(lock_keys);

with 'CBSdkd::MessageRole';

# This gets the real handle from the numeric ID, or dies otherwise.
has 'cbo' => (is => 'rw',
              lazy => 1,
              default => sub {
                if (! $_[0]->handle_id) {
                    die "This is a control message. You should not call this method " .
                        "for control messages"
                }
                
                $Handles->{$_[0]->handle_id}->cbo or die "Couldn't find handle!"
              });

# Converts JSON to a message object
sub decode {
    my ($cls,$txt) = @_;
    my $o = decode_json($txt);
    lock_keys(%$o);
    my $self = $cls->new(
        reqid => $o->{ReqID},
        handle_id => $o->{Handle},
        command => $o->{Command},
        payload => $o->{CommandData}
    );
    return $self;
}


# Clones some parameters from the request to the response. This is the usual
# boilerplate, and avoids us writing it each time we make a new response
sub create_response {
    my ($self,%respopts) = @_;
    my $resp = CBSdkd::Response->new(
        reqid => $self->reqid,
        handle_id => $self->handle_id,
        command => $self->command,
        %respopts
    );
    return $resp;
}

# The response class:
package CBSdkd::Response;
use Moo;
use strict;
use warnings;
use JSON::XS qw(encode_json);

with 'CBSdkd::MessageRole';

# We need to provide a status, a phase, and a payload.
# Currently, the 'PHASE' is not really implemented (but *may* be used by the
# sdkd implementation to signal events of note..)
#
# Status is zero for successful responses (i.e. the command was executed OK).
# This does not mean the memcached/couchbase operation was successful, for responses
# which may return extended results.

has 'status' => (is => 'ro', required => 1);
has 'phase' => (is => 'ro', default => sub { 'COMPLETE' });
has 'errstr' => (is => 'ro');

sub PayloadField { "ResponseData" }

# Encodes the response as a JSON string.
sub encode {
    my $self = shift;
    my $o = $self->to_hash();
    $o->{Phase} = $self->phase;
    $o->{Status} = $self->status;
    
    if ($self->status && $self->errstr) {
        $o->{ErrorString} = $self->errstr;
    }
    
    return encode_json($o);
}


package CBSdkd::Handle;
use strict;
use warnings;
use Moo;
use Time::HiRes qw(sleep);
use Log::Fu;

use CBSdkd::Errors;
use CBSdkd::Dataset;

has 'cbo' => (is => 'rw');
has 'fp' => (is => 'ro', required => 1);
has 'id' => (is => 'ro', required => 1);

has 'handlers' => (is => 'ro', default => sub {
    {

    'MC_DS_MUTATE_SET' => "cmd_mutate",
    'MC_DS_MUTATE_APPEND' => "cmd_mutate",
    'MC_DS_MUTATE_PREPEND' => "cmd_mutate",
    'MC_DS_MUTATE_ADD' => "cmd_mutate",
    'MC_DS_MUTATE_REPLACE'=> "cmd_mutate",
    
    'MC_DS_DELETE' => "cmd_kop",
    'MC_DS_TOUCH' => "cmd_kop",
    
    'MC_DS_GET' => "cmd_retrieve"
    
    }
});

sub cmd_mutate {
    my ($self,$msg) = @_;
    my $params = $msg->payload;
    my $hid = $msg->handle_id;
    
    my ($subop) = ($msg->command =~ m/MUTATE_(.+)/);
    
    my ($dataset,$cbo);
    
    {
        my @okv = ds_verify_common($msg);
        if (!$okv[0]) {
            return $okv[1];
        } else {
            ($cbo,$dataset) = @okv[1,2];
        }
    }
    

    
    my $options = $params->{Options} || {};
    my $delay = $options->{DelayMsec} || 0;
    
    my %stats;
    my %fullres;
    
    my @extra_args;
    
    if ($options->{Expiry}) {
        push @extra_args, $options->{Expiry};
    }
    
    my $func = $CBSdkd::Errors::MutationMap{$subop};
    my $iter = $dataset->iter();
    while ($iter->next) {
        my $k = $iter->key();
        my $v = $iter->value();
        my $rv = $cbo->$func($k,$v,@extra_args);
        my $status;
        if ($rv->is_ok) {
            $status = 0;
        } else {
            $status = extract_error_common($rv->errnum) ||
                (SUBSYSf_UNKNOWN | ERROR_GENERIC);
        }
        $stats{$status}++;
        if ($options->{Detailed}) {
            $fullres{$k} = $status;
        }
        if ($delay) {
            sleep($delay / 1000);
        }
    }
    
    my $payload = { Summary => \%stats };
    
    if ($options->{Detailed}) {
        $payload->{Details} = \%fullres
    };
    
    my $resp = $msg->create_response(status => 0, payload => $payload);
    return $resp;
}


sub cmd_retrieve {
    my ($self,$msg) = @_;
    
    my ($dataset,$cbo);
    {
        my @okv = ds_verify_common($msg);
        if (!$okv[0]) {
            return $okv[1];
        } else {
            ($cbo,$dataset) = @okv[1,2];
        }
    }
    
    my (%stats,%fullres);
    my $is_detailed = $msg->payload->{Options}->{Detailed};
    my $delay = $msg->payload->{Options}->{DelayMsec} || 0;
    my $iter = $dataset->iter();
    while ($iter->next()) {
        my $k = $iter->key();
        my $v = $iter->value();

        my $rv = $cbo->get($k);
        my $status = 0;
        if (!$rv->is_ok) {
            $status = extract_error_common($rv->errnum);
            $status ||= SUBSYSf_UNKNOWN | ERROR_GENERIC;
        } else {
            if ( (defined $v) && $rv->value ne $v) {
                $status = SUBSYSf_KVOPS | KVOPS_EMATCH;
            }
        }
        
        $stats{$status}++;
        
        if ($is_detailed) {
            $fullres{$k} = [$status, $rv->value];
        }
        
        if ($delay) {
            sleep($delay / 1000);
        }
    }
    
    my $payload = {
        Summary => \%stats
    };
    if ($is_detailed) {
        $payload->{Details} = \%fullres;
    }
    return $msg->create_response(status => 0, payload => $payload);
}

sub cmd_kop {
    my ($self,$msg) = @_;
    my ($dataset,$cbo);
    {
        my @okv = ds_verify_common($msg);
        if (!$okv[0]) {
            return $okv[1];
        } else {
            ($cbo,$dataset) = @okv[1,2];
        }
    }
    
    my $func;
    my @args;
    my $delay = $msg->payload->{Options}->{Expiry} || 0;
    
    if ($msg->command eq 'MC_DS_DELETE') {
        $func = 'remove';
        if ($msg->payload->{Options}->{CAS}) {
            return $msg->create_response(status => SUBSYSf_SDKD | SDKD_ENOIMPL,
                                         errstr => "CAS not implemented",
                                         payload => {})
        }
    } else {
        $func = 'touch';
        if (!$cbo->payload->{Options}->{Expiry}) {
            return $msg->create_response(status => SUBSYSf_SDKD | SDKD_EINVAL,
                                         errstr => "Must supply expiry for touch",
                                         payload => {});
        }
        push @args, $cbo->payload->{Options}->{Expiry};
    }
    
    my %stats;
    my $iter = $dataset->iter();
    while ($iter->next) {
        
        my $rv = $cbo->$func($iter->key(), @args);
        if ($rv->is_ok) {
            $stats{0}++;
            next;
        }
        
        my $status = extract_error_common($rv->errnum);
        $status ||= SUBSYSf_UNKNOWN | ERROR_GENERIC;
        $stats{$status}++;
        if ($delay) {
            sleep($delay / 1000);
        }
    }
    
    return $msg->create_response(status => 0,
                                 payload => { Summary => \%stats });
}

sub process_message {
    my ($self,$msg) = @_;
    if (!$msg->handle_id) {
        return
            $msg->create_response(status => SUBSYSf_SDKD | SDKD_EINVAL,
                                  errstr => "Handle received control message",
                                  payload => {});
    } elsif ($msg->handle_id() != $self->id) {
        return 
            $msg->create_response(status => SUBSYSf_SDKD | SDKD_ENOHANDLE,
                                  errstr => "No such handle (wrong socket?)",
                                  payload => {});
    } else {
        
        my $handler = $self->handlers->{$msg->command};
        if (!$handler) {
            return
                $msg->create_response(status => SUBSYSf_SDKD | SDKD_ENOIMPL,
                                       errstr => "Command not implemented",
                                       payload => {});
        } else {
            return ($self->$handler($msg));
        }
    }
}


sub mainloop {
    my $self = shift;
    log_err("Initiating main loop..");
    while ( (my $line = $self->fp->getline())) {
        my $msg = CBSdkd::Request->decode($line);
        $self->fp->print($self->process_message($msg)->encode() . "\n");
    }
    log_err("Exiting main loop..", $!);
}

package CBSdkd::Control;
use strict;
use warnings;
use Moo;

use JSON::XS qw(decode_json encode_json);
use Log::Fu;
use Data::Dumper::Concise;

use Couchbase::Client;
use Couchbase::Client::Errors;

use CBSdkd::Errors;
use CBSdkd::Dataset;

has 'handlers' => (is => 'ro',
                   default => sub {
    {
    'NEWHANDLE' => "cmd_newhandle",
    'NEWDATASET' => "cmd_newdataset"
    }
});

sub msg2cbo {
    my ($self,$msg) = @_;
    
    my $params = $msg->payload();
    
    my $constructor = {
        server => $params->{Hostname} . ":" . $params->{Port},
        bucket => $params->{Bucket}
    };
    if ($params->{Username}) {
        $constructor->{username} = $params->{Username};
        $constructor->{password} = $params->{Password}
    }
    if ($params->{Timeout}) {
        $constructor->{timeout} = $params->{Timeout}
    }
    
    my $cbo = Couchbase::Client->new($constructor);
    my @errors = @{$cbo->get_errors};
    my $status;
    my %respopts;
    
    if (@errors) {
        my $first = shift @errors;
        $status = SUBSYSf_UNKNOWN | ERROR_GENERIC;
        my $ext_status = extract_error_common($first->[0]);
        if ($ext_status) {
            $status = $ext_status;
        }
        $respopts{errstr} = $first->[1];
        $cbo = undef;
    } else {
        $status = 0;        
    }
    
    $respopts{status} = $status;
    
    my $resp = $msg->create_response(
        %respopts,
        payload => {}
    );
    
    return ($resp,$cbo);

}

sub cmd_newdataset {
    my ($self,$msg) = @_;
    my $k = $msg->payload();
    
    eval {
        CBSdkd::Dataset->ds_decode($k);
    }; if ($@) {
        my ($status) = ($@ =~ /SDKD_ERROR:.+(\d+)/);
        $status ||= SUBSYSf_SDKD | ERROR_GENERIC;
        return $msg->create_response(status => $status,
                              errstr => $@,
                              payload => {});
    }
    
    return $msg->create_response(
        status => 0,
        payload => {}
    );
}

sub process_message {
    my ($self,$msg) = @_;
    my $handler = $self->handlers->{$msg->command};
    my $resp;
    
    if (!$handler) {
        # check if this goes into any of the handles..
        my $hid = $msg->handle_id();
        if (!$hid) {
            $resp = $msg->create_response(status => SUBSYSf_SDKD|SDKD_ENOIMPL,
                                          errstr => "Not Implemented",
                                          payload => {});
        } elsif ((my $handle = $Handles->{$hid})) {
            $resp = $handle->process_message($msg);
        } else {
            $resp = $msg->create_response(status => SUBSYSf_SDKD|SDKD_ENOHANDLE,
                                          errstr => "No such handle",
                                          payload => {} );
        }
    } else {
        $resp = $self->$handler($msg);
    }
    
    return $resp;
}

sub run {
    my $self = shift;
    die "Not implemented in base class!";
}


# Simple single-process model..
package CBSdkd::Control::Single;
use strict;
use warnings;
use Moo;
use IO::Handle;
extends 'CBSdkd::Control';


sub cmd_newhandle {
    my ($self,$msg) = @_;
    my ($resp,$cbo) = $self->msg2cbo($msg);
    if ($cbo) {
        $Handles->{$resp->handle_id} = CBSdkd::Handle->new(
            id => $resp->handle_id,
            fp => undef,
            cbo => $cbo
        );
    }
    return $resp;
}

sub run {
    my $self = shift;
    select STDERR;
    
    my $rfp = IO::Handle->new();
    my $wfp = IO::Handle->new();
    
    $rfp->fdopen(fileno(STDIN), "r");
    $wfp->fdopen(fileno(STDOUT), "w");
    
    $wfp->autoflush(1);
    
    while ( (my $line = $rfp->getline() )) {
        my $msg = CBSdkd::Request->decode($line);
        my $resp = $self->process_message($msg);
        $wfp->print($resp->encode() . "\n");
    }
}


# Fork-accept based model..
package CBSdkd::Control::MP;
use strict;
use warnings;
use Moo;
use Log::Fu { level => "INFO" };

BEGIN {
    CBSdkd::Errors->import();
}

my $MPControl;

extends 'CBSdkd::Control';

has 'sockinfo_file' => (is => 'ro', required => 1);
has 'accept_fh' => (is => 'rw');
has 'control_fh' => (is => 'rw');
has 'pids' => (is => 'ro', default => sub { +{} } );

use IO::Select;
use IO::Socket::INET;
use Socket;
use POSIX qw(:sys_wait_h :errno_h);

END {
    if ($MPControl) {
        foreach my $pid (keys %{ $MPControl->pids }) {
            kill(9, $pid);
        }
    }
}

sub do_child {
    my ($self,$newsock) = @_;
    $Log::Fu::LINE_PREFIX = $$ . " ";
    
    log_debug("Will try and get new message...");
    
    my $line = $newsock->getline();
    die "Couldn't get message" unless $line;
    
    my $msg = CBSdkd::Request->decode($line);
    
    if ($msg->command ne 'NEWHANDLE') {
        $msg->create_response(status => SUBSYSf_SDKD|SDKD_EINVAL,
                              errstr => "Bad command in this sequence (expected NEWHANDLE)",
                              payload => {});
        $newsock->print($msg->encode() . "\n");
        log_err("Got command but it's not a NEWHANDLE");
        exit(1);
    }
    
    my ($resp,$cbo) = $self->msg2cbo($msg);
    if (!$cbo) {
        $newsock->print($msg->encode() . "\n");
        exit(1);
    }
    
    my $handle = CBSdkd::Handle->new(
        id => $resp->handle_id,
        fp => $newsock,
        cbo => $cbo
    );
    
    $Handles->{$resp->handle_id} = $handle;
    
    $newsock->print($resp->encode() . "\n");
    
    $handle->mainloop();
    exit(1);
}

sub run {
    my $self = shift;
    $MPControl = $self;
    $Log::Fu::LINE_PREFIX = $$ . " ";
    
    my $select = IO::Select->new();
    my $sock = IO::Socket::INET->new(
        LocalAddr => '127.0.0.1',
        LocalPort => 0,
        Listen  => 16,
        Blocking => 1,
        proto => 'tcp'
    );
    
    
    $SIG{CHLD} = sub {
        my $pid = waitpid(-1, 0);
        die "Waited for PID with WNOHANG, but returned no PID ($!)" unless $pid;
        delete $self->pids->{$pid};
    };
    
    die "Couldn't establish socket: $!" unless $sock;
    my $port = [ unpack_sockaddr_in($sock->sockname()) ];
    die "Couldn't get port (getsockname): $!" unless $port;
    
    $port = $port->[0];
    
    log_warn("Listening on $port");
    
    open my $fh, ">", $self->sockinfo_file or die $self->sockinfo_file.": $!";
    print $fh "$port\n";
    close($fh);
    log_infof("Wrote port information to %s", $self->sockinfo_file);
    
    $self->accept_fh($sock);
    my $ctl = $sock->accept() or die "accept: $!";
    
    $self->control_fh($ctl);
    
    my %dispatch = (
        fileno($self->control_fh), 'control',
        fileno($self->accept_fh), 'accept',
    );
    
    $select->add($self->control_fh, $self->accept_fh);
        
    while (1) {
        my @readable = $select->can_read();
        if (!@readable) {
            my $errno_save = $!;
            if ($errno_save == EINTR) {
                next;
            }
            die "select(): $!";
        }
        foreach my $s (@readable) {
            
            my $t = $dispatch{fileno($s)};
            log_debugf("Socket=%s, Type=%s", $s, $t);
            if ($t eq 'control') {
                log_debug("Got new control message..");
                my $line = $s->getline();
                if (!$line) {
                    log_err("Remote end closed the connection. Exiting..");
                    exit(0);
                }
                my $msg = CBSdkd::Request->decode($line);
                my $resp = $self->process_message($msg);
                $s->print($resp->encode() . "\n");
            } elsif ($t eq 'accept') {
                
                log_debug("Will accept()...");
                my $newsock = $s->accept();
                log_debug("Have new socket $newsock");
                
                my $pid = fork();
                
                if (!$pid) {
                    
                    # Destroy handles from the parent process, if any (is this
                    # possible? )
                    
                    %$Handles = ();
                    
                    close($self->accept_fh);
                    close($self->control_fh);
                    $MPControl = undef;
                    
                    $self->do_child($newsock);
                } else {
                    $self->pids->{$pid} = 1;
                    close($newsock);
                }
            } else {
                die "WTF - No such type: $t/$s";
            }
        }
    }
}


package main;
use strict;
use warnings;
use Getopt::Long;
GetOptions(
    'infofile=s' => \my $Infofile,
    'mode=s' => \my $Mode,
    'help' => \my $WantHelp
);

if ($WantHelp) {
    print <<"EOH";
$0 [ --mode=MODE --infofile=FILE ]

--mode      Specify a mode, either 'single' or 'mp'
--infofile  For 'mp' modes, specify a file to convey port information
EOH
    exit(0);
}

$Mode ||= 'SINGLE';
$Mode = uc($Mode);
if ($Mode eq 'MP') {
    if (!$Infofile) {
        die ("Expected information conduit, but didn't get any!");
    }
    my $o = CBSdkd::Control::MP->new(
        sockinfo_file => $Infofile
    );
    $o->run();
} elsif ($Mode eq 'SINGLE') {
    my $o = CBSdkd::Control::Single->new();
    $o->run();
}