#!/usr/bin/perl

my $Handles = {};
my $DataSets = {};

# Define the error codes. The boring part is generated automatically via
# the srcutil/errdefs.pl and copy-pasted here.
package CBSdkd::Errors;
use strict;
use warnings;
use base qw(Exporter);
our @EXPORT;
use Constant::Generate {
    SUBSYSf_UNKNOWN      => 0x1,
    SUBSYSf_CLUSTER      => 0x2,
    SUBSYSf_CLIENT       => 0x4,
    SUBSYSf_MEMD         => 0x8,
    SUBSYSf_NETWORK      => 0x10,
    SUBSYSf_SDKD         => 0x20,
    SUBSYSf_KVOPS        => 0x40,
    
    SDKD_EINVAL          => 0x200,
    SDKD_ENOIMPL         => 0x300,
    SDKD_ENOHANDLE       => 0x400,
    SDKD_ENODS           => 0x500,
    SDKD_ENOREQ          => 0x600,
    
    ERROR_GENERIC        => 0x100,
    
    CLIENT_ETMO          => 0x200,
    
    CLUSTER_EAUTH        => 0x200,
    CLUSTER_ENOENT       => 0x300,
    
    MEMD_ENOENT          => 0x200,
    MEMD_ECAS            => 0x300,
    MEMD_ESET            => 0x400,
    MEMD_EVBUCKET        => 0x500,
    
    KVOPS_EMATCH         => 0x200,
    
}, export => 1, type => 'bit';



package CBSdkd::MessageRole;
# This class defines our message base
use strict;
use warnings;
use Moo::Role;

has 'reqid' => (is => 'ro', required => 1);
has 'handle_id' => (is => 'ro', required => 1);
has 'command' => (is => 'ro', required => 1);

has 'payload' => (is => 'ro', default => sub { +{} });

sub to_hash {
    my $self = shift;
    my $o = {
        Command => $self->command,
        ReqID => $self->reqid,
        Handle => $self->handle_id,
        $self->PayloadField, $self->payload
    };
    return $o;
}


package CBSdkd::Request;
# This is the request class.. boring details here..
use Moo;
use strict;
use warnings;
use JSON::XS qw(decode_json);
use Hash::Util qw(lock_keys);

with 'CBSdkd::MessageRole';

has 'cbo' => (is => 'rw',
              lazy => 1,
              default => sub {
                $Handles->{$_[0]->handle_id} or die "Couldn't find handle!"
              });


sub decode {
    my ($cls,$txt) = @_;
    my $o = decode_json($txt);
    lock_keys(%$o);
    my $self = $cls->new(
        reqid => $o->{ReqID},
        handle_id => $o->{Handle},
        command => $o->{Command},
        payload => $o->{CommandData}
    );
    return $self;
}

sub create_response {
    my ($self,%respopts) = @_;
    my $resp = CBSdkd::Response->new(
        reqid => $self->reqid,
        handle_id => $self->handle_id,
        command => $self->command,
        %respopts
    );
    return $resp;
}

package CBSdkd::Response;
# This is the response we send out to the network..
use Moo;
use strict;
use warnings;
use JSON::XS qw(encode_json);

with 'CBSdkd::MessageRole';
has 'status' => (is => 'ro', required => 1);
has 'phase' => (is => 'ro', default => sub { 'COMPLETE' });
has 'errstr' => (is => 'ro');

sub PayloadField { "ResponseData" }

sub encode {
    my $self = shift;
    my $o = $self->to_hash();
    $o->{Phase} = $self->phase;
    $o->{Status} = $self->status;
    
    if ($self->status && $self->errstr) {
        $o->{ErrorString} = $self->errstr;
    }
    
    return encode_json($o);
}


use strict;
use warnings;
use JSON::XS qw(decode_json encode_json);
use Log::Fu;
use Data::Dumper::Concise;

use Couchbase::Client;
use Couchbase::Client::Errors;

use Time::HiRes qw(sleep);

BEGIN {
    CBSdkd::Errors->import();
}

# Map Couchbase::Client error codes unto ones SDKD understands.
my %ERRMAP = (
    COUCHBASE_BUCKET_ENOENT,    SUBSYSf_CLUSTER | CLUSTER_ENOENT,
    COUCHBASE_AUTH_ERROR,       SUBSYSf_CLUSTER | CLUSTER_EAUTH,
    COUCHBASE_NETWORK_ERROR,    SUBSYSf_NETWORK | ERROR_GENERIC,
    
    COUCHBASE_KEY_ENOENT,       SUBSYSf_MEMD    | MEMD_ENOENT,
    
    COUCHBASE_ETIMEDOUT,        SUBSYSf_CLIENT  | CLIENT_ETMO
);

sub extract_error_common {
    my $cberr = shift;
    my $ecode = $ERRMAP{$cberr};
    return $ecode;
}

sub cmd_newhandle {
    my $msg = shift;
    my $params = $msg->payload();
    
    my $constructor = {
        server => $params->{Hostname} . ":" . $params->{Port},
        bucket => $params->{Bucket}
    };
    if ($params->{Username}) {
        $constructor->{username} = $params->{Username};
        $constructor->{password} = $params->{Password}
    }
    if ($params->{Timeout}) {
        $constructor->{timeout} = $params->{Timeout}
    }
    
    my $cbo = Couchbase::Client->new($constructor);
    my @errors = @{$cbo->get_errors};
    my $status;
    my %respopts;
    
    if (@errors) {
        my $first = shift @errors;
        $status = SUBSYSf_UNKNOWN | ERROR_GENERIC;
        my $ext_status = extract_error_common($first->[0]);
        if ($ext_status) {
            $status = $ext_status;
        }
        $respopts{errstr} = $first->[1];
    } else {
        $status = 0;
        $Handles->{$msg->handle_id} = $cbo;
    }
    
    $respopts{status} = $status;
    
    my $resp = $msg->create_response(
        %respopts,
        payload => {}
    );
    
    return $resp;
}


my %MutationMap = (
    APPEND => 'append',
    PREPEND => 'prepend',
    SET => 'set',
    REPLACE => 'replace',
);

# returns ($ok,$dataset,$cbo)
# or (undef,$error_response)
sub _ds_verify_common {
    my $msg = shift;
    
    my $params = $msg->payload;
    my $hid = $msg->handle_id;
    
    my ($subop) = ($msg->command =~ m/MUTATE_(.+)/);
    
    my $dataset = [];
    
    if ( (my $tmpds = $params->{Options}->{Dataset}) ) {
        if (ref $tmpds eq 'HASH') {
            while (my ($k,$v) = each %$tmpds) {
                push @$dataset, [ $k, $v ];
            }
        } else {
            foreach (@$tmpds) {
                push @$dataset, [ $_ ];
            }
        }
        
    } else {
        $dataset = $DataSets->{$params->{DSID}};
        if (!$dataset) {
            return (undef, $msg->create_response(
                status => SUBSYSf_SDKD | SDKD_ENODS,
                payload => {}
            ));
        }
    }
    
    eval {
        $msg->cbo
    }; if ($@) {
        
        return (undef, $msg->create_response(
            status => SUBSYSf_SDKD | SDKD_ENOHANDLE,
            errstr => "Can't find handle"
        ));
    }
    
    return (1, $msg->cbo, $dataset);
}

sub cmd_mutate {
    my $msg = shift;
    my $params = $msg->payload;
    my $hid = $msg->handle_id;
    
    my ($subop) = ($msg->command =~ m/MUTATE_(.+)/);
    
    my ($dataset,$cbo);
    
    {
        my @okv = _ds_verify_common($msg);
        if (!$okv[0]) {
            return $okv[1];
        } else {
            ($cbo,$dataset) = @okv[1,2];
        }
    }
    

    
    my $options = $params->{Options} || {};
    my $delay = $options->{DelayMsec} || 0;
    
    my %stats;
    my %fullres;
    
    my @extra_args;
    
    if ($options->{Expiry}) {
        push @extra_args, $options->{Expiry};
    }
    
    my $func = $MutationMap{$subop};
    
    foreach my $dsinfo (@$dataset) {
        my ($k,$v,undef) = @$dsinfo;
        my $rv = $cbo->$func($k,$v,@extra_args);
        my $status;
        if ($rv->is_ok) {
            $status = 0;
        } else {
            $status = extract_error_common($rv->errnum) ||
                (SUBSYSf_UNKNOWN | ERROR_GENERIC);
        }
        $stats{$status}++;
        if ($options->{Detailed}) {
            $fullres{$k} = $status;
        }
    }
    
    my $payload = {
        Summary => \%stats
    };
    if ($options->{Detailed}) {
        $payload->{Details} = \%fullres
    };
    
    my $resp = $msg->create_response(status => 0, payload => $payload);
    return $resp;
}


sub cmd_retrieve {
    my $msg = shift;
    my ($dataset,$cbo);
    {
        my @okv = _ds_verify_common($msg);
        if (!$okv[0]) {
            return $okv[1];
        } else {
            ($cbo,$dataset) = @okv[1,2];
        }
    }
    
    my (%stats,%fullres);
    my $is_detailed = $msg->payload->{Options}->{Detailed};
    
    foreach my $ds (@$dataset) {
        my $rv = $cbo->get($ds->[0]);
        my $status = 0;
        if (!$rv->is_ok) {
            $status = extract_error_common($rv->errnum);
            $status ||= SUBSYSf_UNKNOWN | ERROR_GENERIC;
        } else {
            if ( (defined $ds->[1]) && $rv->value ne $ds->[1]) {
                $status = SUBSYSf_KVOPS | KVOPS_EMATCH;
            }
            $ds->[2] = $rv->cas;
        }
        $stats{$status}++;
        if ($is_detailed) {
            $fullres{$ds->[0]} = [$status, $rv->value];
        }
    }
    
    my $payload = {
        Summary => \%stats
    };
    if ($is_detailed) {
        $payload->{Details} = \%fullres;
    }
    return $msg->create_response(status => 0, payload => $payload);
}


sub cmd_newdataset {
    my $msg = shift;
    my $k = $msg->payload();
    my $id = $k->{ID};
    if (exists $DataSets->{$id}) {
        warn "Overriding existing DSID $id";
    }
    
    $DataSets->{$id} = $k->{Items};
    return $msg->create_response(
        status => 0,
        payload => {}
    );
}

my %MSGHANDLERS = (
    'NEWHANDLE' => \&cmd_newhandle,
    'NEWDATASET' => \&cmd_newdataset,
    
    'MC_DS_MUTATE_SET' => \&cmd_mutate,
    'MC_DS_MUTATE_APPEND' => \&cmd_mutate,
    'MC_DS_MUTATE_PREPEND' => \&cmd_mutate,
    'MC_DS_MUTATE_ADD' => \&cmd_mutate,
    'MC_DS_MUTATE_REPLACE'=> \&cmd_mutate,
    
    'MC_DS_GET' => \&cmd_retrieve,    
);

# Make stuff non-buffered, just for kicks
select STDERR;
$|=1;
select STDOUT;
$|=1;


select STDERR;

while (my $line = <STDIN>) {
    
    my $msg = CBSdkd::Request->decode($line);
    
    my $response;
    
    my $handler = $MSGHANDLERS{$msg->command};
    if (!$handler) {
        $response = $msg->create_response(
            status => SUBSYSf_SDKD | SDKD_ENOIMPL,
            errstr => "Command not implemented"
        );
    } else {
        $response = $handler->($msg);
    }
    
    
    print STDOUT $response->encode() . "\n";
}