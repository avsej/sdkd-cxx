#!/usr/bin/perl

my $Handles = {};
my $DataSets = {};

# Define the error codes. The boring part is generated automatically via
# the srcutil/errdefs.pl and copy-pasted here.

# Error codes are a bitflag of two integers, the subsystem and the minor code.
# The subsystem is a 'SUBSYSf_' constant, the error code is prefixed by the name
# of the subsystem..

package CBSdkd::Errors;
use strict;
use warnings;
use base qw(Exporter);
our @EXPORT;
use Constant::Generate {
    SUBSYSf_UNKNOWN      => 0x1,
    SUBSYSf_CLUSTER      => 0x2,
    SUBSYSf_CLIENT       => 0x4,
    SUBSYSf_MEMD         => 0x8,
    SUBSYSf_NETWORK      => 0x10,
    SUBSYSf_SDKD         => 0x20,
    SUBSYSf_KVOPS        => 0x40,
    
    SDKD_EINVAL          => 0x200,
    SDKD_ENOIMPL         => 0x300,
    SDKD_ENOHANDLE       => 0x400,
    SDKD_ENODS           => 0x500,
    SDKD_ENOREQ          => 0x600,
    
    ERROR_GENERIC        => 0x100,
    
    CLIENT_ETMO          => 0x200,
    
    CLUSTER_EAUTH        => 0x200,
    CLUSTER_ENOENT       => 0x300,
    
    MEMD_ENOENT          => 0x200,
    MEMD_ECAS            => 0x300,
    MEMD_ESET            => 0x400,
    MEMD_EVBUCKET        => 0x500,
    
    KVOPS_EMATCH         => 0x200,
    
}, export => 1, type => 'bit';



# This class defines the message 'header' (insofar as we can do this in JSON):
package CBSdkd::MessageRole;
use strict;
use warnings;
use Moo::Role;

# A message will always have a RequestID, Handle ID (0 if it's a special 'Control')
# message, and a command.
# A message will optionally (but usually, in practice) have a payload or data
# section.

has 'reqid' => (is => 'ro', required => 1);
has 'handle_id' => (is => 'ro', required => 1);
has 'command' => (is => 'ro', required => 1);

has 'payload' => (is => 'ro', default => sub { +{} });


# This function converts the perl object to a hash, suitable for passing to the
# JSON encoder
sub to_hash {
    my $self = shift;
    my $o = {
        Command => $self->command,
        ReqID => $self->reqid,
        Handle => $self->handle_id,
        $self->PayloadField, $self->payload
    };
    return $o;
}

# Subclass for requests.
package CBSdkd::Request;
use Moo;
use strict;
use warnings;
use JSON::XS qw(decode_json);
use Hash::Util qw(lock_keys);

with 'CBSdkd::MessageRole';

# This gets the real handle from the numeric ID, or dies otherwise.
has 'cbo' => (is => 'rw',
              lazy => 1,
              default => sub {
                if (! $_[0]->handle_id) {
                    die "This is a control message. You should not call this method " .
                        "for control messages"
                }
                
                $Handles->{$_[0]->handle_id} or die "Couldn't find handle!"
              });

# Converts JSON to a message object
sub decode {
    my ($cls,$txt) = @_;
    my $o = decode_json($txt);
    lock_keys(%$o);
    my $self = $cls->new(
        reqid => $o->{ReqID},
        handle_id => $o->{Handle},
        command => $o->{Command},
        payload => $o->{CommandData}
    );
    return $self;
}


# Clones some parameters from the request to the response. This is the usual
# boilerplate, and avoids us writing it each time we make a new response
sub create_response {
    my ($self,%respopts) = @_;
    my $resp = CBSdkd::Response->new(
        reqid => $self->reqid,
        handle_id => $self->handle_id,
        command => $self->command,
        %respopts
    );
    return $resp;
}

# The response class:
package CBSdkd::Response;
use Moo;
use strict;
use warnings;
use JSON::XS qw(encode_json);

with 'CBSdkd::MessageRole';

# We need to provide a status, a phase, and a payload.
# Currently, the 'PHASE' is not really implemented (but *may* be used by the
# sdkd implementation to signal events of note..)
#
# Status is zero for successful responses (i.e. the command was executed OK).
# This does not mean the memcached/couchbase operation was successful, for responses
# which may return extended results.

has 'status' => (is => 'ro', required => 1);
has 'phase' => (is => 'ro', default => sub { 'COMPLETE' });
has 'errstr' => (is => 'ro');

sub PayloadField { "ResponseData" }

# Encodes the response as a JSON string.
sub encode {
    my $self = shift;
    my $o = $self->to_hash();
    $o->{Phase} = $self->phase;
    $o->{Status} = $self->status;
    
    if ($self->status && $self->errstr) {
        $o->{ErrorString} = $self->errstr;
    }
    
    return encode_json($o);
}


use strict;
use warnings;
use JSON::XS qw(decode_json encode_json);
use Log::Fu;
use Data::Dumper::Concise;

use Couchbase::Client;
use Couchbase::Client::Errors;

use Time::HiRes qw(sleep);

BEGIN {
    CBSdkd::Errors->import();
}

# Map Couchbase::Client error codes unto ones SDKD understands.
my %ERRMAP = (
    COUCHBASE_BUCKET_ENOENT,    SUBSYSf_CLUSTER | CLUSTER_ENOENT,
    COUCHBASE_AUTH_ERROR,       SUBSYSf_CLUSTER | CLUSTER_EAUTH,
    
    COUCHBASE_CONNECT_ERROR,    SUBSYSf_NETWORK | ERROR_GENERIC,
    COUCHBASE_NETWORK_ERROR,    SUBSYSf_NETWORK | ERROR_GENERIC,
    
    COUCHBASE_ENOMEM,           SUBSYSf_MEMD    | ERROR_GENERIC,
    
    
    COUCHBASE_KEY_ENOENT,       SUBSYSf_MEMD    | MEMD_ENOENT,
    
    COUCHBASE_ETIMEDOUT,        SUBSYSf_CLIENT  | CLIENT_ETMO,
    
    # This could either be a network error, or a client error :/
    COUCHBASE_ETMPFAIL,         SUBSYSf_CLIENT  | ERROR_GENERIC | SUBSYSf_NETWORK
);

sub extract_error_common {
    my $cberr = shift;
    my $ecode = $ERRMAP{$cberr};
    if (!$ecode) {
        warn "Couldn't map error $cberr";
    }
    return $ecode;
}

sub cmd_newhandle {
    my $msg = shift;
    my $params = $msg->payload();
    
    my $constructor = {
        server => $params->{Hostname} . ":" . $params->{Port},
        bucket => $params->{Bucket}
    };
    if ($params->{Username}) {
        $constructor->{username} = $params->{Username};
        $constructor->{password} = $params->{Password}
    }
    if ($params->{Timeout}) {
        $constructor->{timeout} = $params->{Timeout}
    }
    
    my $cbo = Couchbase::Client->new($constructor);
    my @errors = @{$cbo->get_errors};
    my $status;
    my %respopts;
    
    if (@errors) {
        my $first = shift @errors;
        $status = SUBSYSf_UNKNOWN | ERROR_GENERIC;
        my $ext_status = extract_error_common($first->[0]);
        if ($ext_status) {
            $status = $ext_status;
        }
        $respopts{errstr} = $first->[1];
    } else {
        $status = 0;
        $Handles->{$msg->handle_id} = $cbo;
    }
    
    $respopts{status} = $status;
    
    my $resp = $msg->create_response(
        %respopts,
        payload => {}
    );
    
    return $resp;
}


my %MutationMap = (
    APPEND => 'append',
    PREPEND => 'prepend',
    SET => 'set',
    REPLACE => 'replace',
);

sub _ref2ds {
    my $ref = shift;
    my $ret = [];
    
    if (ref $ref eq 'HASH') {
        while (my ($k,$v) = each %$ref) {
            push @$ret, [ $k, $v ];
        }
    } elsif (ref $ref eq 'ARRAY') {
        foreach (@$ref) {
            push @$ret, [ $_ ];
        }
    } else {
        die "Unsupported reference type " . ref $ref;
    }
    return $ret;
}

# returns ($ok,$dataset,$cbo)
# or (undef,$error_response)
sub _ds_verify_common {
    my $msg = shift;
    
    my $params = $msg->payload;
    my $hid = $msg->handle_id;
    
    my ($subop) = ($msg->command =~ m/MUTATE_(.+)/);
    
    my $dataset = [];
    
    if ( (my $tmpds = $params->{Options}->{Dataset}) ) {
        $dataset = _ref2ds($tmpds);        
    } else {
        $dataset = $DataSets->{$params->{DSID}};
        if (!$dataset) {
            return (undef, $msg->create_response(
                status => SUBSYSf_SDKD | SDKD_ENODS,
                payload => {}
            ));
        }
    }
    
    eval {
        $msg->cbo
    }; if ($@) {
        
        return (undef, $msg->create_response(
            status => SUBSYSf_SDKD | SDKD_ENOHANDLE,
            errstr => "Can't find handle"
        ));
    }
    
    return (1, $msg->cbo, $dataset);
}

sub cmd_mutate {
    my $msg = shift;
    my $params = $msg->payload;
    my $hid = $msg->handle_id;
    
    my ($subop) = ($msg->command =~ m/MUTATE_(.+)/);
    
    my ($dataset,$cbo);
    
    {
        my @okv = _ds_verify_common($msg);
        if (!$okv[0]) {
            return $okv[1];
        } else {
            ($cbo,$dataset) = @okv[1,2];
        }
    }
    

    
    my $options = $params->{Options} || {};
    my $delay = $options->{DelayMsec} || 0;
    
    my %stats;
    my %fullres;
    
    my @extra_args;
    
    if ($options->{Expiry}) {
        push @extra_args, $options->{Expiry};
    }
    
    my $func = $MutationMap{$subop};
    
    foreach my $dsinfo (@$dataset) {
        my ($k,$v,undef) = @$dsinfo;
        my $rv = $cbo->$func($k,$v,@extra_args);
        my $status;
        if ($rv->is_ok) {
            $status = 0;
        } else {
            $status = extract_error_common($rv->errnum) ||
                (SUBSYSf_UNKNOWN | ERROR_GENERIC);
        }
        $stats{$status}++;
        if ($options->{Detailed}) {
            $fullres{$k} = $status;
        }
        if ($delay) {
            sleep($delay / 1000);
        }
    }
    
    my $payload = {
        Summary => \%stats
    };
    if ($options->{Detailed}) {
        $payload->{Details} = \%fullres
    };
    
    my $resp = $msg->create_response(status => 0, payload => $payload);
    return $resp;
}


sub cmd_retrieve {
    my $msg = shift;
    my ($dataset,$cbo);
    {
        my @okv = _ds_verify_common($msg);
        if (!$okv[0]) {
            return $okv[1];
        } else {
            ($cbo,$dataset) = @okv[1,2];
        }
    }
    
    my (%stats,%fullres);
    my $is_detailed = $msg->payload->{Options}->{Detailed};
    my $delay = $msg->payload->{Options}->{DelayMsec} || 0;
    
    foreach my $ds (@$dataset) {
        my $rv = $cbo->get($ds->[0]);
        my $status = 0;
        if (!$rv->is_ok) {
            $status = extract_error_common($rv->errnum);
            $status ||= SUBSYSf_UNKNOWN | ERROR_GENERIC;
        } else {
            
            if ( (defined $ds->[1]) && $rv->value ne $ds->[1]) {
                $status = SUBSYSf_KVOPS | KVOPS_EMATCH;
            }
            $ds->[2] = $rv->cas;
        }
        
        $stats{$status}++;
        
        if ($is_detailed) {
            $fullres{$ds->[0]} = [$status, $rv->value];
        }
        
        if ($delay) {
            sleep($delay / 1000);
        }
    }
    
    my $payload = {
        Summary => \%stats
    };
    if ($is_detailed) {
        $payload->{Details} = \%fullres;
    }
    return $msg->create_response(status => 0, payload => $payload);
}

sub cmd_kop {
    my $msg = shift;
    my ($dataset,$cbo);
    {
        my @okv = _ds_verify_common($msg);
        if (!$okv[0]) {
            return $okv[1];
        } else {
            ($cbo,$dataset) = @okv[1,2];
        }
    }
    
    my $func;
    my @args;
    my $delay = $msg->payload->{Options}->{Expiry} || 0;
    
    if ($msg->command eq 'MC_DS_DELETE') {
        $func = 'remove';
        if ($msg->payload->{Options}->{CAS}) {
            return $msg->create_response(status => SUBSYSf_SDKD | SDKD_ENOIMPL,
                                         errstr => "CAS not implemented",
                                         payload => {})
        }
    } else {
        $func = 'touch';
        if (!$cbo->payload->{Options}->{Expiry}) {
            return $msg->create_response(status => SUBSYSf_SDKD | SDKD_EINVAL,
                                         errstr => "Must supply expiry for touch",
                                         payload => {});
        }
        push @args, $cbo->payload->{Options}->{Expiry};
    }
    
    my %stats;
    
    foreach my  $ds (@$dataset) {
        my $rv = $cbo->$func($ds->[0], @args);
        if ($rv->is_ok) {
            $stats{0}++;
            next;
        }
        
        my $status = extract_error_common($rv->errnum);
        $status ||= SUBSYSf_UNKNOWN | ERROR_GENERIC;
        $stats{$status}++;
        if ($delay) {
            sleep($delay / 1000);
        }
    }
    
    return $msg->create_response(status => 0,
                                 payload => { Summary => \%stats });
}


sub cmd_newdataset {
    my $msg = shift;
    my $k = $msg->payload();
    my $id = $k->{ID};
    if (exists $DataSets->{$id}) {
        warn "Overriding existing DSID $id";
    }
    
    $DataSets->{$id} = _ref2ds($k->{Items});
    return $msg->create_response(
        status => 0,
        payload => {}
    );
}

my %MSGHANDLERS = (
    'NEWHANDLE' => \&cmd_newhandle,
    'NEWDATASET' => \&cmd_newdataset,
    
    'MC_DS_MUTATE_SET' => \&cmd_mutate,
    'MC_DS_MUTATE_APPEND' => \&cmd_mutate,
    'MC_DS_MUTATE_PREPEND' => \&cmd_mutate,
    'MC_DS_MUTATE_ADD' => \&cmd_mutate,
    'MC_DS_MUTATE_REPLACE'=> \&cmd_mutate,
    
    'MC_DS_DELETE' => \&cmd_kop,
    'MC_DS_TOUCH' => \&cmd_kop,
    
    'MC_DS_GET' => \&cmd_retrieve,    
);

# Make stuff non-buffered, just for kicks
select STDERR;
$|=1;
select STDOUT;
$|=1;


select STDERR;

while (my $line = <STDIN>) {
    
    my $msg = CBSdkd::Request->decode($line);
    
    my $response;
    
    my $handler = $MSGHANDLERS{$msg->command};
    if (!$handler) {
        $response = $msg->create_response(
            status => SUBSYSf_SDKD | SDKD_ENOIMPL,
            errstr => "Command not implemented"
        );
    } else {
        $response = $handler->($msg);
    }
    
    
    print STDOUT $response->encode() . "\n";
}